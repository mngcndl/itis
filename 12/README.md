## Homework
1. Создать класс Vector2D (Геометрия, двумерный)
   1. Конструктор с аргументами __init__(x, y), или нулями если аргументы не переданы
   2. add(Vector2D) - сложение вектора с другим вектором, результат возвращается как новый объект.
   3. add2(Vector2D) - сложение вектора с другим вектором, результат сохраняется в том, у кого был вызван этот метод; 
   4. sub(Vector2D) - вычитание из вектора другого вектора, результат возвращается как новый объект; 
   5. sub2(Vector2D) - вычитание из вектора другого вектора, результат сохраняется в том векторе, у кого был вызван этот метод; 
   6. mult(a) - умножение вектора на вещественное число, результат возвращается как новый объект; 
   7. mult2(a) - умножение вектора на вещественное число, результат сохраняется в векторе; 
   8. __str__() - строковое представление вектора; 
   9. __len__() - длина вектора;
   10. scalarProduct(Vector2D) - скалярное произведение вектора на другой вектор; 
   11. cos(Vector2D) - косинус угла между этим и другим вектором; 
   12. equals(Vector2D) - сравнить вектор с другим вектором;
2. Класс RationalFraction - рациональная дробь. Атрибуты - два целых числа (числитель и знаменатель). Методы:
   1. Конструктор __init__(x, y) дроби со значениями числителя и знаменателя (или нулем по умолчанию); в конструкторах устраняйте дублирование кода; 
   2. reduce() - сокращение дроби; 
   3. add(RationalFraction) - сложение дроби с другой дробью, результат возвращается как новый объект (не забудьте сократить)
   4. add2(RationalFraction) - сложение дроби с другой дробью, результат сохраняется в том, у кого был вызван этот метод (не забудьте сократить); 
   5. sub(RationalFraction) - вычитание из дроби другой дроби, результат возвращается как новый объект (не забудьте сократить); 
   6. sub2(RationalFraction) - вычитание из дроби другой дроби, результат сохраняется в том, у кого был вызван этот метод (не забудьте сократить); 
   7. mult(RationalFraction) - умножение дроби на другую дробь, результат возвращается как новый объект (сократить)
   8. mult2(RationalFraction) - умножение дроби на другую дробь, результат сохраняется; 
   9. div(RationalFraction) - деление дроби на другую дробь, результат возвращается как новый объект (сократить)
   10. div2(RationalFraction) - деление дроби на другую дробь, результат сохраняется; больше не буду писать "возвращается" или "сохраняется", думаю, уже и так понятно.
   11. __str__() - строковое представление дроби (например, -2/3); 
   12. value() - десятичное значение дроби;
   13. equals(RationalFraction) - сравнить дробь с другой дробью (не забывайте, что 2/4 и 1/2 - одна и та же дробь)
   14. numberPart() - целая часть дроби; 
3. Создать класс ComplexNumber - [комплексное число](https://ru.wikipedia.org/wiki/Комплексное_число). Атрибуты - действительная и мнимая части (два числа). Методы:
   1. конструктор __init__(a, b) комплексного числа с заданными значениями вещественной и мнимой части; в конструкторах устраняйте дублирование кода; Если аргументы не переданы используйте нули;
   2. add(ComplexNumber) - сложение комплексного числа с другим комплексным числом; 
   3. add2(ComplexNumber) - сложение комплексного числа с другим комплексным числом; 
   4. sub(ComplexNumber) - вычитание из комплексного числа  другого комплексного числа; 
   5. sub2(ComplexNumber) - вычитание из комплексного числа другого комплексного числа; 
   6. multNumber(x) - умножение комплексного числа на вещественное число; 
   7. multNumber2(x) - умножение комплексного числа на вещественное число; 
   8. mult(ComplexNumber) - умножение комплексного числа на другое комплексное число; 
   9. mult2(ComplexNumber) - умножение комплексного числа на другое комплексное число; 
   10. div(ComplexNumber) - деление на другое комплексное число; 
   11. div2(ComplexNumber) - деление на другое комплексное число;
   12. __len__() - модуль комплексного числа;
   13. __str__() - строковое представление комплексного числа.  Только без всяких "2 * i + - 3". Проверяйте знаки, чтобы было красиво: 2 * i - 3. 
   14. arg() - аргумент комплексного числа (может понадобиться тригонометрическое представление (читайте ссылку) и арктангенс Math.atan); 
   15. pow(double) - возвести в степень по Формуле Муавра (иные способы запрещены). Внимание - разрешено использование Math.pow для возведения аргумента в степень (т.к. оба аргумента double), также вам понадобятся Math.cos, Math.sin. 
   16. equals(ComplexNumber) - сравнить комплексное число с другим комплексным числом; 
4. Создать класс Matrix2x2 - двумерная матрица из вещественных чисел. Аргументы - содержимое матрицы (лучше, разумеется, хранить двумерным массивом, а то замучаетесь). Методы:
   1. __init__(x) - конструктор для матрицы, у которой каждый элемент равен поданному числу или нулями если X не передан;
   2. set(i, j, x) - задать элемент в позиции 
   3. add(Matrix2x2) - сложение матрицы с другой, новая матрица будет возвращена; 
   4. add2(Matrix2x2) - сложение матрицы с другой, с сохранением результата в текущей; 
   5. sub(Matrix2x2) - вычитание из матрицы другой матрицы, с возвратом новой; 
   6. sub2(Matrix2x2) - вычитание из матрицы другой матрицы, с сохранением результата в текущей; 
   7. multNumber(x) - умножение матрицы на число, с возвратом новой; 
   8. multNumber2(x) - умножение матрицы на число, с сохранением результата в текущей; 
   9. mult(Matrix2x2) - умножение матрицы на другую матрицу, с возвратом новой; 
   10. mult2(Matrix2x2) - умножение матрицы на другую матрицу, с сохранением результата в текущей; 
   11. det() - определитель матрицы; 
   12. transpon() - транспонировать матрицу; 
   13. inverseMatrix() - возвратить обратную матрицу для заданной. Если это невозможно, вывести сообщение об ошибке и вернуть нулевую матрицу (кто вдруг знает исключения, может их использовать). 
   14. equivalentDiagonal() - возвратить эквивалентную диагональную матрицу; 
   15. multVector(Vector2D) - умножить матрицу на двумерный вектор (считая его столбцом) и возвратить получившийся столбец в виде вектора.






